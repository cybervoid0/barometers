generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Image {
  id            String         @id @default(uuid())
  url           String
  blurData      String?
  description   String?
  name          String?
  order         Int?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  categories    Category[]     @relation("CategoryImages")
  barometers    Barometer[]    @relation("BarometerImages")
  manufacturers Manufacturer[] @relation("ManufacturerImages")
  documents     Document[]     @relation("DocumentImages")
}

model Category {
  id          String      @id @default(uuid())
  name        String      @unique
  description String
  label       String
  order       Int
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  barometers  Barometer[]
  images      Image[]     @relation("CategoryImages")
}

/// Movement type
model SubCategory {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  description String?
  barometers  Barometer[]
}

model Barometer {
  /// Table ID
  id              String   @id @default(uuid())
  /// Collection internal ID
  collectionId    String   @unique
  /// Serial number written on the barometer
  serial          String?
  /// Barometer descriptive name
  name            String   @unique
  /// URL Representation of the name
  slug            String   @unique
  /// History of the barometer. May contain Markdown layout
  description     String
  /// Barometer dimensions, e.g. weight, length, diameter etc.
  dimensions      Json?
  /// Date for barometers sorting
  date            DateTime
  /// Date to display on pages, e.g. "c.1870", "mid 19th century"
  dateDescription String
  /// History of ownership and origin of the barometer
  provenance      String?
  /// Estimated price
  estimatedPrice  Float?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  purchasedAt DateTime?

  // table relations
  conditionId    String
  manufacturerId String
  categoryId     String
  subCategoryId  Int?
  subCategory    SubCategory?       @relation(fields: [subCategoryId], references: [id])
  category       Category           @relation(fields: [categoryId], references: [id])
  condition      Condition          @relation(fields: [conditionId], references: [id])
  manufacturer   Manufacturer       @relation(fields: [manufacturerId], references: [id])
  images         Image[]            @relation("BarometerImages")
  reports        InaccuracyReport[]
  materials      Material[]         @relation("BarometerMaterials")
  documents      Document[]         @relation("DocumentBarometers")
}

model Material {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  description String?
  barometers  Barometer[] @relation("BarometerMaterials")
}

model InaccuracyReport {
  id            String                 @id @default(uuid())
  barometerId   String
  barometer     Barometer              @relation(fields: [barometerId], references: [id])
  reporterName  String
  reporterEmail String
  description   String
  status        InaccuracyReportStatus @default(PENDING)
  createdAt     DateTime               @default(now())
}

enum InaccuracyReportStatus {
  PENDING
  REVIEWED
  RESOLVED
}

model PdfFile {
  id             String       @id @default(uuid())
  name           String
  url            String
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  manufacturerId String
  manufacturer   Manufacturer @relation("PdfFiles", fields: [manufacturerId], references: [id], onDelete: Cascade)
}

model Manufacturer {
  id           String         @id @default(uuid())
  firstName    String?
  name         String         @unique
  slug         String         @unique
  countries    Country[]      @relation("ManufacturerCountries")
  city         String?
  description  String?
  url          String?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  barometers   Barometer[]
  images       Image[]        @relation("ManufacturerImages")
  icon         Bytes?
  // self-referencing relations
  // some brands may have multiple successors and/or predecessors
  successors   Manufacturer[] @relation("ManufacturerSuccessors")
  predecessors Manufacturer[] @relation("ManufacturerSuccessors")
  pdfFiles     PdfFile[]      @relation("PdfFiles")
}

model Country {
  id            Int            @id @default(autoincrement())
  name          String         @unique
  flag          String?        @unique
  code          String?
  manufacturers Manufacturer[] @relation("ManufacturerCountries")
}

model Condition {
  id          String      @id @default(uuid())
  name        String
  value       Int
  description String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  barometers  Barometer[]
  documents   Document[]
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  password  String?
  name      String
  role      AccessRole
  avatarURL String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  Customer  Customer?
}

model Document {
  id                  String    @id @default(uuid())
  title               String
  catalogueNumber     String    @unique
  documentType        String
  subject             String?
  creator             String?
  /// Date for documents sorting
  date                DateTime?
  /// Date to display on pages, e.g. "c.1870", "mid 19th century"
  dateDescription     String?
  placeOfOrigin       String?
  language            String?
  physicalDescription String?
  /// List of inscriptions, stamps, etc.
  annotations         String[]
  provenance          String?
  acquisitionDate     DateTime?
  description         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  conditionId       String?
  condition         Condition?  @relation(fields: [conditionId], references: [id])
  images            Image[]     @relation("DocumentImages")
  relatedBarometers Barometer[] @relation("DocumentBarometers")
}

enum AccessRole {
  USER
  OWNER
  ADMIN
}

/// SHOP

model Customer {
  id               String   @id @default(uuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stripeCustomerId String   @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  orders           Order[]
}

model Product {
  id               String         @id @default(uuid())
  name             String
  slug             String         @unique
  description      String?
  stripeProductId  String         @unique
  stripePriceIdEUR String? // Stripe Price ID для EUR
  stripePriceIdUSD String? // Stripe Price ID для USD
  priceEUR         Int? // Цена в центах (евро)
  priceUSD         Int? // Цена в центах (доллары)
  stock            Int            @default(0)
  isActive         Boolean        @default(true)
  weight           Int? // Вес в граммах
  dimensions       Json? // Размеры для доставки
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  images           ProductImage[]
  orderItems       OrderItem[]
}

model ProductImage {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  url       String
  alt       String?
  order     Int      @default(0)
  createdAt DateTime @default(now())
}

model Order {
  id                    String          @id @default(uuid())
  orderNumber           String          @unique
  customerId            String
  customer              Customer        @relation(fields: [customerId], references: [id])
  shippingAddressId     String
  shippingAddress       ShippingAddress @relation(fields: [shippingAddressId], references: [id])
  status                OrderStatus     @default(PENDING)
  currency              Currency
  subtotal              Int // Сумма в центах
  shippingCost          Int             @default(0) // В центах
  tax                   Int             @default(0) // В центах
  total                 Int // Итого в центах
  stripeSessionId       String?         @unique
  stripePaymentIntentId String?         @unique
  notes                 String?
  trackingNumber        String?
  shippedAt             DateTime?
  deliveredAt           DateTime?
  cancelledAt           DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  items                 OrderItem[]
  payment               Payment?
}

model OrderItem {
  id          String   @id @default(uuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId   String
  product     Product  @relation(fields: [productId], references: [id])
  quantity    Int
  priceAtTime Int // Цена в центах на момент покупки
  createdAt   DateTime @default(now())
}

model ShippingAddress {
  id         String   @id @default(uuid())
  firstName  String
  lastName   String
  email      String
  phone      String?
  address    String
  city       String
  state      String?
  postalCode String
  country    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  orders     Order[]
}

model Payment {
  id                    String        @id @default(uuid())
  orderId               String        @unique
  order                 Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  stripePaymentIntentId String        @unique
  amount                Int // sum in cents
  currency              Currency
  status                PaymentStatus @default(PENDING)
  paidAt                DateTime?
  refundedAt            DateTime?
  refundAmount          Int? // in cents
  failureMessage        String?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
}

enum OrderStatus {
  PENDING // created, waiting for payment
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

enum Currency {
  EUR
  USD
}
